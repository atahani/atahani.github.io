<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on بلاگ احمد طحانی</title>
    <link>http://atahani.com/tags/docker/index.xml</link>
    <description>Recent content in Docker on بلاگ احمد طحانی</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fa</language>
    <copyright>Ahmad Tahani</copyright>
    <atom:link href="http://atahani.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ایجاد یک کلاستر با docker swarm</title>
      <link>http://atahani.com/cluster-with-docker-swarm</link>
      <pubDate>Thu, 01 Sep 2016 22:04:27 +0430</pubDate>
      
      <guid>http://atahani.com/cluster-with-docker-swarm</guid>
      <description>&lt;p align=&#34;justify&#34;&gt;
  سه‌شنبه نهم شهریور در اولین همایش داکر درباره docker swarm ارائه‌ای داشتم، چون قرار بود برای آن دمویی داشته باشیم و &lt;code&gt;RAM&lt;/code&gt; سیستم پایین بود (۴ گیگ) ریسک نکردم و از ارائه فیلم نگرفتم، برای همین در این پست سعی می‌کنم مراحل دموی ارائه شده که ایجاد یک کلاستر با &lt;code&gt;swarm&lt;/code&gt; بود رو به صورت کامل بنویسم.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  اول از همه اگر با داکر آشنا نیستید، می‌توانید در &lt;a href=&#34;https://faranesh.com/programming/14863-docker-in-action&#34;&gt;دوره‌ی آشنایی با داکر وب سایت فرانش&lt;/a&gt; 😎 ثبت‌نام کنید.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  اسلاید ارائه را هم می‌توانید در &lt;a href=&#34;http://goo.gl/a9pmAJ&#34;&gt;گوگل اسلاید&lt;/a&gt; ببینید.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  پروژه‌ی داکر swarm از سال گذشته روی &lt;a href=&#34;https://github.com/docker/swarm&#34;&gt;این مخزن&lt;/a&gt; توسعه‌داده شد، شرکت داکر برای سرویس‌ها ابری خودش از آن استفاده می‌کرد، همچنین با stable شدن آن شرکت‌های دیگری نیز از آن در دنیای واقعی استفاده کردند، در طی این یک سال بهبود‌هایی در زمنیه شبکه، امنیت، service discovery در داکر swarm انجام شد، همچنین شرکت‌ داکر برای ترقیب کاربران به استفاده از آن، به کل swarm را به docker منتقل کرد به گونه‌ای که در &lt;a href=&#34;https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/&#34;&gt;ورژن 1.12&lt;/a&gt; شما در سه سوت می‌توانید یک کلاستر swarm راه‌اندازی کنید. نکته‌ای که باید بهش اشاره کرده این هست که توسعه swarm در &lt;a href=&#34;https://github.com/docker/swarm&#34;&gt;مخزن اصلی&lt;/a&gt; آن همچنان ادامه دارد ! در اینجا بحث اصلی استفاده از راهکار ارائه شده در docker ورژن 1.12 است.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  اول از همه یک http سرور خیلی خیلی ساده با &lt;a href=&#34;http://atahani.com/golang-intro/&#34;&gt;زبان گو&lt;/a&gt; داریم که ازش به عنوان برنامه‌ اجرایی در این دمو استفاده می‌کنیم 👇
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
)

func hello(res http.ResponseWriter, req *http.Request) {
	hostName, err := os.Hostname()
	if err != nil {
		log.Fatalln(err)
	}
	// io.WriteString(res, fmt.Sprintf(&amp;quot;Hello world from 👉 %v 👈  &amp;quot;, hostName))
	io.WriteString(res, fmt.Sprintf(&amp;quot;Hello world from 👉 %v 👈 containerID 🐋 &amp;quot;, hostName))
}

func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, hello)
	http.ListenAndServe(&amp;quot;:80&amp;quot;, nil)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  خوبی زبان گو این هست که شما می‌توانید از برنامه‌ی خود یک باینری مناسب برای کانتینر ایجاد کنید و بعد در سه خط Dockerfile یک ایمیج خیلی رژیم گرفته ایجاد کنید، مثلاً ایمیج این برنامه شد &lt;code&gt;5.63MB&lt;/code&gt; 👌
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  برای تولید باینری مناسب کانتینر دستور &lt;code&gt;go build&lt;/code&gt; را با این سوییچ‌ها و envها به صورت زیر اجرا کنید:
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  حال که باینری فایل مورد نظر &lt;code&gt;hello-world&lt;/code&gt; را داریم، کافیه یک &lt;code&gt;Dockerfile&lt;/code&gt; سه خطی بنوسید و بعد هم ایمیج رو بسازید!
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;FROM scratch
ADD hello-world /
# default port for hello-world is 80
CMD [&amp;quot;/hello-world&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  دقت کنید چون برنامه در قالب یک باینری فایل هست، شما دیگر از base ایمیج خاصی استفاده نمی‌کنید و همانند ایمیج‌هایی مثل &lt;a href=&#34;https://github.com/tianon/docker-brew-debian/blob/589b967ff4364528ebd686b002a6ee00f00f4657/jessie/Dockerfile&#34;&gt;debian&lt;/a&gt; از &lt;code&gt;scratch&lt;/code&gt; ساخته می‌شود. 💪
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  واسه ایجاد کلاستر یه ubuntu server به صورت مجازی نصب می‌کنیم و بعد فقط کافیه &lt;a href=&#34;https://docs.docker.com/engine/installation/linux/ubuntulinux/&#34;&gt;داکر را روی آن نصب کنیم&lt;/a&gt;، همچنین واسه راحتی کار SSH را روی آن اوکی می‌کنیم تا از طریق &lt;code&gt;SHELL&lt;/code&gt; خود هاست به آن وصل بشویم.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  برای راحتی ۲ سرور مجازی دیگر از روی‌ آن &lt;code&gt;clone&lt;/code&gt; می‌کنیم  😁 الان هر سه نود مورد احتیاج برای این دمو را داریم، یکی از نودها رو به عنوان &lt;code&gt;swarm manager&lt;/code&gt; انتخاب می‌کنیم و روی آن دستور زیر را اجرا می‌کنیم
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  حالا به شما می‌گوید که می‌توانید برای اضافه‌کردن نودهای دیگر به عنوان &lt;code&gt;worker&lt;/code&gt; دستور زیر را در نودهای دیگر وارد نمایید، روی دو نود دیگر این دستور رو اجرا می‌کنیم.
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;docker swarm join \
    --token SWMTKN-1-2t7lf1rv07ht8j5sbt7q4yssbqiaqgeop8yplaaelywyqh6bcm-6k0a07wq8ey7xf85td9cfgwlj \
    192.168.0.59:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  برای نمایش وضعیت نودها و کانتینرهایی که در آن اجرا می‌شود از &lt;a href=&#34;https://github.com/ManoMarks/docker-swarm-visualizer&#34;&gt;یک ویژولایزر&lt;/a&gt; استفاده می‌کنیم، برای اجرای آن ایمیج داکر آن را اجرا می‌کنیم:
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;docker run -it -d -p 8080:8080 -e HOST=[YOURHOST] -v /var/run/docker.sock:/var/run/docker.sock manomarks/visualizer
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  دقت کنید که به جای &lt;code&gt;YOURHOST&lt;/code&gt; باید &lt;code&gt;IP&lt;/code&gt; و یا یک &lt;code&gt;DNS A Record&lt;/code&gt; وارد کنید که &lt;code&gt;IP&lt;/code&gt; نود ۱ را &lt;code&gt;resolve&lt;/code&gt; کند، واسه این کار به راحتی می‌توانید در فایل &lt;code&gt;etc/hosts/&lt;/code&gt; یک &lt;code&gt;hostname&lt;/code&gt; ای برای نود ۱ در نظر بگیرید.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  نکته‌ی مهمی که باید توجه کنید این هست که ایمیج برنامه‌ای که می‌خواهید روی کلاستر &lt;code&gt;scale&lt;/code&gt; شود، باید در تمامی نودها وجود داشته باشد، پس باید با &lt;code&gt;scp&lt;/code&gt; ایمیج برنامه را به نودها انتقال دهید، البته می‌توانید به راحتی &lt;a href=&#34;http://atahani.com/docker-private-registry&#34;&gt;یک داکر رجیستری خصوصی&lt;/a&gt; راه‌اندازی کرده و ایمیج برنامه را به آن &lt;code&gt;PUSH&lt;/code&gt; کنید و هنگام اجرای دستور &lt;code&gt;docker service create&lt;/code&gt; با سوییچ &lt;code&gt;with-registry-auth&lt;/code&gt; اطلاعات کاربری رجیستری را پاس بدهید، که در این حالت تمامی نودهای کلاستر ایمیج مربوطه را از آن رجیستری می‌گیرند.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  حال برای اجرای یک سرویس جدید روی کلاستر، دستور زیر را روی نود اصلی &lt;code&gt;swarm manager&lt;/code&gt; اجرا می‌کنیم:
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;docker service create -p 80:80 --name our_app golang-hello-world:1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  برای اطلاع از سرویس‌های در حال اجرا روی کلاستر 👇
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;docker service ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  برای &lt;code&gt;scale&lt;/code&gt; سرویس در کلاستر از دستور &lt;code&gt;docker service scale our_app=6&lt;/code&gt; استفاده می‌کنیم.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  &lt;p&gt;همچنین شما می‌توانید با دستور &lt;code&gt;docker service update&lt;/code&gt; تغییراتی در کانتینرهای در حال اجرا بدهید، در مثال زیر تمامی کانتیرها به صورت ۲ به ۲ با فاصله زمانی ۱۰ ثانیه ایمیج جدید دریافت می‌کنند.( در حقیقت اول &lt;code&gt;stop &amp;amp; remove&lt;/code&gt; می‌شوند و بعد با ایمیج جدید &lt;code&gt;start&lt;/code&gt; می‌شوند)&lt;/p&gt;

&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;docker service update --image golang-hello-world:1.1 --update-parallelism 2 --update-delay 10s our_app
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  ✋ 👈 در همایش هم گفتم به عنوان تست با &lt;code&gt;swarm&lt;/code&gt; کار کرده‌ام، پس تجربه‌های لازم در محیط &lt;code&gt;production&lt;/code&gt; رو ندارم. فعالین این حوزه آینده خوبی برای &lt;code&gt;swarm&lt;/code&gt; تصور می‌کنند که در یک سال آینده بتواند همانند &lt;a href=&#34;Kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt;  حرفی برای گفتن داشته باشد.
&lt;/p&gt;


&lt;p&gt;&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>دوره آموزشی Continuous Integration</title>
      <link>http://atahani.com/ci</link>
      <pubDate>Sat, 30 Jul 2016 00:45:16 +0430</pubDate>
      
      <guid>http://atahani.com/ci</guid>
      <description>&lt;p align=&#34;justify&#34;&gt;
  &lt;p&gt;&lt;strong&gt;به روز رسانی&lt;/strong&gt; 👈 ویدیوها در در وب سایت فرانش منتشر شده است، می‌توانید به رایگان از &lt;a href=&#34;https://faranesh.com/programming/15206-continuous-integration&#34;&gt;این دوره&lt;/a&gt; بهره ببرید 😉&lt;p align=&#34;justify&#34;&gt;
  &lt;p align=&#34;justify&#34;&gt;
  پنجشنبه‌ی گذشته &lt;a href=&#34;https://evand.ir/events/ioccc8&#34;&gt;هشتمین گردهمایی جامعه آزاد رایانش ابری اصفهان&lt;/a&gt; برگزار شد، قرار بود در سومین جلسه‌ی کارگاه داکر از Continuous Integration بگم، بعد از سمینار آقای &lt;a href=&#34;https://twitter.com/hypermit&#34;&gt;مجید سلامت&lt;/a&gt;، رفتم واسه وصل کردن مک‌بوک به پروژکتور که متاسفانه وصل نمی‌شد، بعد از ۱۵ دقیقه تلاش با کلی ری‌استارت و اعمال مختلف بالاخره تصویر اومد. 😅 (آخر هم نفهمیدم چرا این جوری شده بود، آخه یک ساعت قبل تست کرده بودیم و تصویر روی همان پروژکتور داشتیم 😯)
&lt;/p&gt;&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  برای بحث‌ای مثل &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;CI&lt;/a&gt; و اجرای چنین دمویی ۴۵ دقیقه واقعا کم بود، در حین اجرا هم یک بار داکر هنگ کرد 😩 کلاً کارگاه با مشکلات زیاد به همراه استرس شروع شد و آن کیفیت مطلوب جلسه‌های قبلی رو نداشت، خلاصه اینکه بدجوری زمان کم آوردم و نتوانستم به صورت کامل دموی CI رو اجرا کنم 😔
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  قبل از کارگاه تصمیم داشتم مراحل این دمو را به صورت کامل در قالب یک پست منتشر کنم، با اتفاقاتی که افتاد تصمیم بر آن شد که یک دوره مختصر و مفید ویدیویی تهیه کنم چرا که مواد لازم ( اسلاید، نمونه کد برای دمو و غیره) را داشتم فقط تهیه فیلم بود، آن هم جمعه انجام شد، امیدوارم دوستان از این دوره استفاده کنند 😊
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  اسلاید این دوره نیز در &lt;a href=&#34;https://docs.google.com/presentation/d/1MNH15XJtLEc8m4nVWrxu0Bxzr8PQh_ghutC0jKnu0rQ/edit#slide=id.p&#34;&gt;گوگل اسلاید&lt;/a&gt; قرار گرفته، فعلاً فقط در &lt;a href=&#34;https://www.youtube.com/playlist?list=PL-0EQDLPE23NUJoA-cLWfTHgnfCI6BdQF&#34;&gt;یوتیوب&lt;/a&gt; منتشر شده است، برای وب سایت خوب &lt;a href=&#34;https://faranesh.com/tutors/atahani&#34;&gt;فرانش&lt;/a&gt; نیز آپلود کرده‌ام، امیدوارم به زودی منتشر شود.
&lt;/p&gt;

&lt;iframe width=&#34;640&#34; height=&#34;360&#34; src=&#34;https://www.youtube.com/embed/videoseries?list=PL-0EQDLPE23NUJoA-cLWfTHgnfCI6BdQF&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/1MNH15XJtLEc8m4nVWrxu0Bxzr8PQh_ghutC0jKnu0rQ/embed?start=false&amp;loop=true&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;480&#34; height=&#34;299&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;/p&gt;

</description>
    </item>
    
    <item>
      <title>راه‌حلی برای مشکلات npm</title>
      <link>http://atahani.com/npm_private_server</link>
      <pubDate>Wed, 29 Jun 2016 20:09:42 +0430</pubDate>
      
      <guid>http://atahani.com/npm_private_server</guid>
      <description>&lt;p align=&#34;justify&#34;&gt;
  هفته پیش برای جلسه دوم کارگاه داکر (همایش آزاد رایانش ابری) یک نمونه پروژه باحال درست کردم، سمت کاربر با &lt;code&gt;Reacjs&lt;/code&gt; نوشته شده بود، بعد موقعی که می‌خواستم ایمیج داکر ازش بسازم، یه عالمه پکیج &lt;code&gt;npm&lt;/code&gt; در آن استفاده شده بود که باید دوباره دانلود می‌کرد، برای دور زدن این مشکل ( با &lt;a href=&#34;https://github.com/jteeuwen/go-bindata&#34;&gt;go-bind-data&lt;/a&gt; ) از فایل باینری پروژه یک داکر ایمیج ساختم، خوب این راه‌حل خوبی به نظر می‌رسد چرا چون حجم ایمیج خیلی کم شد (چیزی حدود ۱۱ مگ) ! ولی مشکلی که هست در بحث &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;Continuous integration&lt;/a&gt; باید کل پروژه به صورت اتوماتیک ساخته شده، تست و اجرا شود و در صورت اوکی بودن، باینری آن تولید و بعد ایمیج آن ساخته و به رجیستری منتقل و اجرا شود.
&lt;/p&gt;


&lt;p&gt;&lt;p align=&#34;justify&#34;&gt;
  از این بحث‌ها که بگذریم، مشکل گرفتن ماژول‌های &lt;code&gt;npm&lt;/code&gt; چه در &lt;code&gt;CI&lt;/code&gt; و چه به صورت &lt;code&gt;local&lt;/code&gt; در ایران عزیزمون به خاطر بحث فیلتر‌نت همیشگی بوده، بهترین راه‌حل موجود این است که شما یک &lt;code&gt;NPM cach server&lt;/code&gt; ایجاد کنید، خوشبختانه راه اندازی چنین سرویسی برای خودتان خیلی ساده‌ست، مخصوصاً‌ با داکر 👊
&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;p align=&#34;justify&#34;&gt;
  اول باید تصمیم بگیرید می‌خواهید این کش سرور کجا باشد، هر جایی که باشد مزایای خودش رو دارد، مثلاً برای شرکت‌هایی که چندین توسعه‌دهنده دارند بهترین راه این است که یک کش سرور روی سرور داخلی شرکت بیارند بالا، و بعد روی یکی از سرورهای خارج ایران هم یک کش سرور دیگه‌ای بیاورند بالا تا کش سرور داخلی به آن وصل بشود، این جوری دیگه به کل مشکل دریافت ماژول‌های &lt;code&gt;npm&lt;/code&gt; در شرکت حل خواهد شد، برای مصارف شخصی نیز اگه یه سرور شخصی دارید سه سوت با داکر کش سرور رو بیارید بالا و ازش استفاده کنید 😎
&lt;/p&gt;
&lt;/p&gt;

&lt;p&gt;&lt;p align=&#34;justify&#34;&gt;
  آقای &lt;a href=&#34;http://keyvanfatehi.com/&#34;&gt;کیوان فاتحی&lt;/a&gt; داکر ایمیج &lt;a href=&#34;https://www.npmjs.com/package/sinopia&#34;&gt;sinopia&lt;/a&gt; رو آماده کرده‌اند، پس در سه سوت می‌شه با داکر روی سرور آورد بالا 😊
&lt;/p&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --name sinopia -d -p 4873:4873 keyvanfatehi/sinopia:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;p align=&#34;justify&#34;&gt;
  بعد در ترمینال کلاینت برای ست کردن رجیستری
&lt;/p&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm set registry http://SERVER_IP_ADDRESS:4873
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  &lt;p&gt;حالا هنگام دریافت ماژول‌های &lt;code&gt;npm&lt;/code&gt; اگر قبلاً ماژول مورد نظر داخل سرور بود، از آنجا دریافت می‌کنید اگه هم نبود اول خودش سریع می‌گیره و بعد به سیستم شما انتقال می‌دهد ! چی از این راحت‌تر و بهتر 😬&lt;/p&gt;

&lt;/p&gt;


&lt;p&gt;&lt;p align=&#34;justify&#34;&gt;
  راستی با استفاده از این روش می‌توانید ماژول‌های خصوصی &lt;code&gt;npm&lt;/code&gt; نیز داشته باشید، برای اطلاعات بیشتر می‌توانید به &lt;a href=&#34;https://github.com/kfatehi/docker-sinopia&#34;&gt;مخزن&lt;/a&gt; آن مراجعه کنید.
&lt;/p&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker private registry در سه سوت</title>
      <link>http://atahani.com/docker-private-registry</link>
      <pubDate>Fri, 20 May 2016 23:24:06 +0430</pubDate>
      
      <guid>http://atahani.com/docker-private-registry</guid>
      <description>&lt;p align=&#34;justify&#34;&gt;
  پارسال با ابزار Docker آشنا شدم و برای اینکه مفاهیم از کلم نپره یه دوره‌ آموزشی با عنوان &lt;a href=&#34;https://faranesh.com/programming/14863-docker-in-action&#34;&gt;آشنایی و استفاده از داکر&lt;/a&gt; تهیه کردم، استقبال خوبی هم ازش شد 😊 همان طور که می‌دانید شرکت داکر سرویس داکر هاب را برای ایران مسدود کرده و عملاً با IP ایران نمی‌توانیم ایمیجی دریافت کنیم  😐 دوستان زیادی از جمله &lt;a href=&#34;https://twitter.com/miladkdz&#34;&gt;میلاد&lt;/a&gt; خیلی پگیر این موضوع هستند، با تمام این تلاش‌ها چون قوانین تحریماتی آمریکا هنوز پا برجاست، شرکت داکر همانند سایرین نمی‌تواند مغایر قانون رفتار کند!
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  نحوه‌ی درآمد شرکت داکر به گونه‌ای است که تمام هسته‌ی نرم‌افزاری خودش را به صورت متن‌باز در &lt;a href=&#34;https://github.com/docker&#34;&gt;گیت‌هاب&lt;/a&gt; قرار می‌دهد، یکی از این مخزن‌ها &lt;a href=&#34;https://github.com/docker/distribution&#34;&gt;distribution&lt;/a&gt; است، که خیلی به کار ما می‌آید چرا که هم از طرف داکر تحریم هستیم و هم اینکه برایمان سخت است که برای private image ها بخواهیم پول دلاری پرداخت کنیم.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  کانفیگ و پیاده سازی Private Registry در ورژن ۲ آن خیلی راحت شده، البته اگر &lt;a href=&#34;https://github.com/docker/distribution/blob/master/docs/deploying.md&#34;&gt;داکیومنت&lt;/a&gt; آن را بخوانید نحوه‌ی کانفیگ آن یکم بد توضیح داده شده، در ادامه خیلی ساده مراحل کار توضیح داده می‌شود.
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  &lt;h3 id=&#34;یک-گواهی-tls-می-خواهیم&#34;&gt;یک گواهی TLS می‌خواهیم&lt;/h3&gt;

&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  قبل از هر چیز به یک گواهی TLS احتیاج داریم، فرقی نمی‌کنه گواهی معتبر باشد یا نه ؟ در نحوه‌ی کارکرد آن تائثیری ندارد، ولی بهتر است شما از یک گواهی معتبر استفاده کنید، خوشبختانه به‌ راحتی می‌توانید از طریق &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;letsencrypt&lt;/a&gt; گواهی معتبر رایگان دریافت کرد، برای اطلاعات بیشتر در مورد نحوه‌ی ایجاد کردن گواهی معتبر به &lt;a href=&#34;https://letsencrypt.org/getting-started/&#34;&gt;این آدرس&lt;/a&gt; بروید، خیلی سخت نیست!
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  &lt;h3 id=&#34;ساختن-دایرکتوری-های-مورد-نیاز&#34;&gt;ساختن دایرکتوری‌های مورد نیاز&lt;/h3&gt;

&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ tree /registry/
/registry/
├── auth
│   └── htpasswd
├── certs
│   ├── server.crt
│   └── server.key
├── data
└── docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  &lt;h3 id=&#34;در-نظر-گرفتن-یک-نام-کاربری-و-رمز-عبور-برای-کاربری-که-می-خواهد-به-این-registry-وصل-بشود&#34;&gt;در نظر گرفتن یک نام‌کاربری و رمز عبور برای کاربری که می‌خواهد به این registry وصل بشود&lt;/h3&gt;

&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ docker run --entrypoint htpasswd registry:2 -Bbn testuser testpassword &amp;gt; /registry/auth/htpasswd
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  &lt;h3 id=&#34;اجرای-private-registry-به-وسیله-ی-docker-compose&#34;&gt;اجرای private registry به وسیله‌ی docker-compose&lt;/h3&gt;

&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ vim /registry/docker-compose.yml

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;registry:
  restart: always
  image: registry:2
  ports:
    - 443:443
  environment:
    REGISTRY_HTTP_TLS_CERTIFICATE: /certs/server.crt
    REGISTRY_HTTP_TLS_KEY: /certs/server.key
    REGISTRY_AUTH: htpasswd
    REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd
    REGISTRY_AUTH_HTPASSWD_REALM: basic-realm
    REGISTRY_HTTP_ADDR: :443
    REGISTRY_HTTP_SECRET: topsecretphase
  volumes:
    - /registry/data:/var/lib/registry
    - /registry/certs:/certs
    - /registry/auth:/auth
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  &lt;h3 id=&#34;نحوه-ی-لاگین-کردن-به-private-registry&#34;&gt;نحوه‌ی لاگین کردن به private registry&lt;/h3&gt;

&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ docker login https://docker.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  &lt;h3 id=&#34;نحوه-ی-tag-کردن-یک-ایمیج-و-ارسال-آن-به-registry&#34;&gt;نحوه‌ی Tag کردن یک ایمیج و ارسال آن به registry&lt;/h3&gt;

&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ docker pull golang:1.6 &amp;amp;&amp;amp; docker.example.com/testuser/golang
$ docker push docker.example.com/testuser/golang
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  خوب پس کار زیاد سختی هم نبود، تازه شما می‌توانید کار جالب‌تری هم انجام بدهید، private registry یک قابلیتی دارد به عنوان &lt;a href=&#34;https://github.com/docker/distribution/blob/master/docs/mirror.md&#34;&gt;mirror&lt;/a&gt; که برای کش کردن ایمیج‌ها در سرور داخلی یک شرکت در نظر گرفته شده است تا base image هایی که کارمندان یک شرکت استفاده می‌کند در آن registry کش بشود، خوب وقتی شما چنین قابلیتی را می‌بینید صددرصد با خود می‌گویید چه خوب !! می‌شود از این خصوصیت برای دوز زدن تحریم استفاده کرد، یه سرور خارجی داشته باشیم همه‌ی base image ها داخل آن کش بشود و بعد از اینجا بهش متصل بشویم، درسته این ایده تقریباً عملی هست، ولی مشکلی که وجود دارد این است که داکر برای جستجو داخل image ها و به طور کلی index کردن آن به دامین index.docker.com متصل می‌شود، پس باز تحریم این جا جلوی شما را می‌گیرد، ولی خوب همین که بتوانید از طریق آن base image ها با حجم بالا را بدون proxy دریافت کنید، بد نیست، پس اگه فقط index.docker.com را بزارید پشت proxy دیگه کل مشکل تحریم بر طرف خواهد شد.(امیدوارم به زودی زود تحریم‌های فناوری برداشته بشود!)
&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  &lt;h2 id=&#34;اجرای-private-registry-در-حالت-mirror&#34;&gt;اجرای private registry در حالت mirror&lt;/h2&gt;

&lt;/p&gt;


&lt;p align=&#34;justify&#34;&gt;
  برای اجرای private registry در حالت mirror کافیه این فایل را ایجاد کرده و بعد با docker-compose اجرا کنید
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ vim /registry/docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;registry:
  restart: always
  image: registry:2
  ports:
    - 443:443
  environment:
    REGISTRY_HTTP_TLS_CERTIFICATE: /certs/server.crt
    REGISTRY_HTTP_TLS_KEY: /certs/server.key
    REGISTRY_HTTP_ADDR: :443
    REGISTRY_HTTP_SECRET: topsecretphase
    REGISTRY_PROXY_REMOTEURL: https://registry-1.docker.io
  volumes:
    - /registry/data:/var/lib/registry
    - /registry/certs:/certs
    - /registry/auth:/auth
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  در سمت کلاینت باید docker deamon با این آپشن‌ها اجرا بشود، برای اطلاعات بیشتر به &lt;a href=&#34;https://docs.docker.com/engine/admin/configuring/&#34;&gt;این آدرس&lt;/a&gt; بروید.
&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;$ vim /etc/default/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;DOCKER_OPTS=&amp;quot;--registry-mirror=https://docker. example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ service docker restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p align=&#34;justify&#34;&gt;
  &lt;p&gt;نکته: برای این که ببینید در هنگام گرفتن یک base image چه اتفاقی می‌افتد باید docker daemon را در &lt;a href=&#34;https://docs.docker.com/engine/admin/configuring/#daemon-debugging&#34;&gt;حالت دیباگ&lt;/a&gt; اجرا کنید، اگه دقت کنید هنگام جستوجو، داکر به index.docker.com رجوع می‌کند که تحریم است، ولی به هنگام گرفتن یک base image اولویت با registery ای است که شما تنظیم کرده‌اید پس اگر آن base image در رجیستری شما نبود اول از docker hub گرفته می‌شود و بعد به کلاینت منتقل می‌شود!&lt;/p&gt;

&lt;/p&gt;


&lt;p&gt;&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;

&lt;p align=&#34;justify&#34;&gt;
  
&lt;/p&gt;
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>